---
title: "对抗性审查 (Adversarial Review)"
description: 防止懒惰的“看起来不错”式审查的强制推理技术
---

通过要求发现问题来强制进行更深入的分析。

## 什么是对抗性审查？

一种审查者*必须*发现问题的审查技术。不允许“看起来不错”。审查者采取愤世嫉俗的立场 - 假设存在问题并找到它们。

这不是关于消极。它是关于强制进行真正的分析，而不是对提交的任何内容进行橡皮图章式的粗略浏览。

**核心规则：** 你必须发现问题。零发现会触发暂停 - 重新分析或解释原因。

## 为什么它有效

正常的审查受到确认偏差的困扰。你浏览工作，没有什么跳出来，你就批准了它。“发现问题”的任务打破了这种模式：

- **强制彻底性** - 在你努力找到问题之前不能批准
- **捕捉遗漏** - “这里少了什么？”成为一个自然的问题
- **提高信号质量** - 发现是具体和可操作的，而不是模糊的担忧
- **信息不对称** - 在全新的上下文（没有原始推理的访问权限）中运行审查，这样你评估的是 artifact，而不是意图

## 何处使用

对抗性审查出现在整个 BMad Workflows 中 - Code Review、实现准备就绪检查、规范验证等。有时它是一个必填步骤，有时是可选的（如高级启发或 Party Mode）。该模式适应任何需要详细审查的 artifact。

## 需要人工过滤

因为 AI 被*指示*去发现问题，它会发现问题 - 即使问题不存在。预期会有误报：伪装成问题的吹毛求疵、对意图的误解，或完全是幻觉出来的担忧。

**你决定什么是真实的。** 审查每一个发现，忽略噪音，修复重要的问题。

## 示例

代替：

> “认证实现看起来合理。批准。”

对抗性审查产生：

> 1. **HIGH** - `login.ts:47` - 失败尝试没有速率限制
> 2. **HIGH** - Session token 存储在 localStorage 中（XSS 易受攻击）
> 3. **MEDIUM** - 密码验证仅在客户端进行
> 4. **MEDIUM** - 没有失败登录尝试的审计日志
> 5. **LOW** - 魔术数字 `3600` 应该是 `SESSION_TIMEOUT_SECONDS`

第一次审查可能错过了一个安全漏洞。第二次抓住了四个。

## 迭代和收益递减

解决发现的问题后，考虑再次运行它。第二次通过通常能捕捉到更多。第三次也不总是无用的。但每一次通过都需要时间，最终你会遇到收益递减 - 只是吹毛求疵和错误的发现。

:::tip[更好的审查]
假设存在问题。寻找缺失的东西，而不仅仅是错误的东西。
:::
